function physio = readCMRRPhysio(varargin)
% -------------------------------------------------------------------------
% readCMRRPhysio.m
% -------------------------------------------------------------------------
% Read physiological log files from CMRR MB sequences (>=R013, >=VD13A)
%   E. Auerbach, CMRR, 2015-9
%
% Usage #1 (individual .log files):
%    physio = readCMRRPhysio(base_filename, [show_plot]);
% Usage #2 (single encoded DICOM file):
%    physio = readCMRRPhysio(DICOM_filename, [show_plot]);
%
% This function expects to find either some combination of individual log
% files (*_ECG.log, *_RESP.log, *_PULS.log, *_EXT.log, *_Info.log)
% generated by the CMRR C2P sequences >=R013, or a single encoded "_PHYSIO"
% DICOM file generated by the CMRR C2P sequences >=R015.
%
% Inputs:
%    base_filename  = 'Physio_DATE_TIME_UUID'
%    DICOM_filename = 'XXX.dcm'
%    show_plot = 1 to graphically display traces after import (optional)
%
% Returns:
%    Physio traces will be returned for ECG1, ECG2, ECG3, ECG4, RESP, PULS,
%    EXT1, and EXT2 signals. Only active traces (with nonzero values) will
%    be returned.
%
%    The unit of time is clock ticks (2.5 ms per tick).
%        physio.UUID: unique identifier string for this measurement
%        physio.SliceMap: [2 x Volumes x Slices] array
%            (1,:,:) = start time stamp of each volume/slice
%            (2,:,:) = finish time stamp of each volume/slice
%        physio.ACQ: [total scan time x 1] array
%            value = 1 if acquisition is active at this time; 0 if not
%        physio.ECG1: [total scan time x 1] array
%        physio.ECG2: [total scan time x 1] array
%        physio.ECG3: [total scan time x 1] array
%        physio.ECG4: [total scan time x 1] array
%            value = ECG signal on this channel
%        physio.RESP: [total scan time x 1] array
%            value = RESP signal on this channel
%        physio.PULS: [total scan time x 1] array
%            value = PULS signal on this channel
%        physio.EXT: [total scan time x 1] array
%            value = 1 if EXT signal detected; 0 if not
%        physio.EXT2: [total scan time x 1] array
%            value = 1 if EXT2 signal detected; 0 if not

% this is the file format this function expects; must match log file version
ExpectedVersion = 'EJA_1';

% say hello
fprintf('\nreadCMRRPhysio: E. Auerbach, CMRR, 2015-9\n\n');

% check input arguments
if (nargin < 1) || (nargin > 2)
    error('Invalid number of inputs.');
end
fn = varargin{1};
if (nargin == 2)
    show_plot = varargin{2};
else
    show_plot = 0;
end

% first, check if the base is pointing to a DICOM we should extract
if (2 == exist(fn,'file'))
    fprintf('Found %s\n', fn);
    if (~isdicom(fn))
        error('Invalid syntax for text log file import!\n    Usage: physio = readCMRRPhysio(base_filename)\n%s', ...
              '    Inputs: base_filename = ''Physio_DATE_TIME_UUID''');
    end
    fprintf('Attempting to read CMRR Physio DICOM format file...\n');
    warning('off','images:dicominfo:attrWithSameName');
    dcmInfo = dicominfo(fn);
    if (~isempty(dcmInfo) && isfield(dcmInfo,'ImageType') && strcmp(dcmInfo.ImageType,'ORIGINAL\PRIMARY\RAWDATA\PHYSIO') ...
            && isfield(dcmInfo,'Private_7fe1_10xx_Creator') && strcmp(deblank(char(dcmInfo.Private_7fe1_10xx_Creator)),'SIEMENS CSA NON-IMAGE'))
        np = size(dcmInfo.Private_7fe1_1010,1);
        rows = dcmInfo.AcquisitionNumber;
        columns = np/rows;
        numFiles = columns/1024;
        if (rem(np,rows) || rem(columns,1024)), error('Invalid image size (%dx%d)!', columns, rows); end
        dcmData = reshape(dcmInfo.Private_7fe1_1010,[],numFiles)';
        % encoded DICOM format: columns = 1024*numFiles
        %                       first row: uint32 datalen, uint32 filenamelen, char[filenamelen] filename
        %                       remaining rows: char[datalen] data
        foundECG  = 0;
        foundRESP = 0;
        foundPULS = 0;
        foundEXT  = 0;
        [~,~,endian] = computer;
        needswap = ~strcmp(endian,'L');
        for idx=1:numFiles
            datalen = typecast(dcmData(idx,1:4),'uint32');
            if needswap, datalen = swapbytes(datalen); end
            filenamelen = typecast(dcmData(idx,5:8),'uint32');
            if needswap, filenamelen = swapbytes(filenamelen); end
            filename = char(dcmData(idx,9:9+filenamelen-1));
            logData = dcmData(idx,1025:1025+datalen-1);
            fprintf('  Decoded: %s\n', filename);
            if (strcmp(filename(end-9+1:end),'_Info.log'))
                fnINFO = logData;
            elseif (strcmp(filename(end-8+1:end),'_ECG.log'))
                fnECG  = logData;
                foundECG = 1;
            elseif (strcmp(filename(end-9+1:end),'_RESP.log'))
                fnRESP = logData;
                foundRESP = 1;
            elseif (strcmp(filename(end-9+1:end),'_PULS.log'))
                fnPULS = logData;
                foundPULS = 1;
            elseif (strcmp(filename(end-8+1:end),'_EXT.log'))
                fnEXT = logData;
                foundEXT = 1;
            end
        end
        fprintf('\n');
    else
        error('%s is not a valid DICOM format file!', fn);
    end
    
% if we don't have an encoded DICOM, check what text log files we have
else
    fnINFO = [fn '_Info.log'];
    fnECG  = [fn '_ECG.log'];
    fnRESP = [fn '_RESP.log'];
    fnPULS = [fn '_PULS.log'];
    fnEXT  = [fn '_EXT.log'];
    if (2 ~= exist(fnINFO, 'file')), error('%s not found!', fnINFO); end
    foundECG  = (2 == exist(fnECG , 'file'));
    foundRESP = (2 == exist(fnRESP, 'file'));
    foundPULS = (2 == exist(fnPULS, 'file'));
    foundEXT  = (2 == exist(fnEXT , 'file'));
end

if (~foundECG && ~foundRESP && ~foundPULS && ~foundEXT)
    error('No data files (ECG/RESP/PULS/EXT) found!');
end

% read in the data
[SliceMap, UUID1, NumSlices, NumVolumes, FirstTime, LastTime, NumEchoes] = readParseFile(fnINFO, 'ACQUISITION_INFO', ExpectedVersion, 0, 0);
if (LastTime <= FirstTime), error('Last timestamp is not greater than first timestamp, aborting...'); end
ActualSamples = LastTime - FirstTime + 1;
ExpectedSamples = ActualSamples + 8; % some padding at the end for worst case EXT sample at last timestamp

if (foundECG)
    [ECG, UUID2] = readParseFile(fnECG, 'ECG', ExpectedVersion, FirstTime, ExpectedSamples);
    if (~strcmp(UUID1, UUID2)), error('UUID mismatch between Info and ECG files!'); end
end

if (foundRESP)
    [RESP, UUID3] = readParseFile(fnRESP, 'RESP', ExpectedVersion, FirstTime, ExpectedSamples);
    if (~strcmp(UUID1, UUID3)), error('UUID mismatch between Info and RESP files!'); end
end

if (foundPULS)
    [PULS, UUID4] = readParseFile(fnPULS, 'PULS', ExpectedVersion, FirstTime, ExpectedSamples);
    if (~strcmp(UUID1, UUID4)), error('UUID mismatch between Info and PULS files!'); end
end

if (foundEXT)
    [EXT, UUID5] = readParseFile(fnEXT, 'EXT', ExpectedVersion, FirstTime, ExpectedSamples);
    if (~strcmp(UUID1, UUID5)), error('UUID mismatch between Info and EXT files!'); end
end

fprintf('Formatting data...\n');
ACQ = zeros(ExpectedSamples,1,'uint16');
for v=1:NumVolumes
    for s=1:NumSlices
        for e=1:NumEchoes
            ACQ(SliceMap(1,v,s,e)+1:SliceMap(2,v,s,e)+1,1) = 1;
        end
    end
end
    
fprintf('\n');
fprintf('Slices in scan:      %d\n', NumSlices);
fprintf('Volumes in scan:     %d\n', NumVolumes);
if (NumEchoes > 1)
    fprintf('Echoes per slc/vol:  %d\n', NumEchoes);
end
fprintf('First timestamp:     %d\n', FirstTime);
fprintf('Last timestamp:      %d\n', LastTime);
fprintf('Total scan duration: %d ticks\n', ActualSamples);
fprintf('Total scan duration: %.4f s\n', double(ActualSamples)*2.5/1000);
fprintf('\n');

% only return active (nonzero) traces
physio.UUID = UUID1;
physio.SliceMap = SliceMap;
physio.ACQ = ACQ;
if ((1 == exist('ECG' , 'var')) && ~isempty(ECG)  && nnz(ECG(:,1))), physio.ECG1 = ECG(:,1); end
if ((1 == exist('ECG' , 'var')) && ~isempty(ECG)  && nnz(ECG(:,2))), physio.ECG2 = ECG(:,2); end
if ((1 == exist('ECG' , 'var')) && ~isempty(ECG)  && nnz(ECG(:,3))), physio.ECG3 = ECG(:,3); end
if ((1 == exist('ECG' , 'var')) && ~isempty(ECG)  && nnz(ECG(:,4))), physio.ECG4 = ECG(:,4); end
if ((1 == exist('RESP', 'var')) && ~isempty(RESP) && nnz(RESP))    , physio.RESP = RESP;     end
if ((1 == exist('PULS', 'var')) && ~isempty(PULS) && nnz(PULS))    , physio.PULS = PULS;     end
if ((1 == exist('EXT' , 'var')) && ~isempty(EXT)  && nnz(EXT(:,1))), physio.EXT  = EXT(:,1); end
if ((1 == exist('EXT' , 'var')) && ~isempty(EXT)  && nnz(EXT(:,2))), physio.EXT2 = EXT(:,2); end

% plot data in a rudimentary way if requested
% if too large, only plot the middle 1k ticks or so
if (show_plot)
    display_max = 1000;
    start_tick = 1;
    end_tick = ActualSamples;
    if (ActualSamples > display_max)
        start_tick = floor(ActualSamples/2) - floor(display_max/2) + 1;
        end_tick = start_tick + display_max - 1;
    end
    figure;
    hold on;
    miny = 50000; maxy = -50000; % actual range is 0..4095
    if (isfield(physio,'ECG1')), [miny, maxy] = plot_trace(physio.ECG1(start_tick:end_tick), miny, maxy, 'y', false); end
    if (isfield(physio,'ECG2')), [miny, maxy] = plot_trace(physio.ECG2(start_tick:end_tick), miny, maxy, 'y', false); end
    if (isfield(physio,'ECG3')), [miny, maxy] = plot_trace(physio.ECG3(start_tick:end_tick), miny, maxy, 'y', false); end
    if (isfield(physio,'ECG4')), [miny, maxy] = plot_trace(physio.ECG4(start_tick:end_tick), miny, maxy, 'y', false); end
    if (isfield(physio,'RESP')), [miny, maxy] = plot_trace(physio.RESP(start_tick:end_tick), miny, maxy, 'm', false); end
    if (isfield(physio,'PULS')), [miny, maxy] = plot_trace(physio.PULS(start_tick:end_tick), miny, maxy, 'r', false); end
    if (isfield(physio,'EXT' )), [miny, maxy] = plot_trace(physio.EXT (start_tick:end_tick), miny, maxy, 'c', true);  end
    if (isfield(physio,'EXT2')), [miny, maxy] = plot_trace(physio.EXT2(start_tick:end_tick), miny, maxy, 'g', true);  end
    plot_trace(physio.ACQ(start_tick:end_tick), miny, maxy, 'k', true);
    axis([1 double(min(display_max, ActualSamples)) miny-maxy*0.05 maxy+maxy*0.05]);
end

%--------------------------------------------------------------------------

function [arr, varargout] = readParseFile(fn, LogDataType, ExpectedVersion, FirstTime, ExpectedSamples)
% read and parse log file

if (isa(fn,'uint8'))
    % if fn is uint8, we read it directly from DICOM
    fprintf('Parsing %s data...\n', LogDataType);
    inData = char(fn);
else
    % otherwise, fn is a filename
    fprintf('Reading %s file...\n', LogDataType);
    fp = fopen(fn);
    inData = fread(fp, Inf, '*char');
    fclose(fp);
end

% echoes parameter was not added until R015a, so prefill a default value
% for compatibility with older data
NumEchoes = uint16(1);
varargout{6} = NumEchoes;

% mgetl returns a cell array where each cell is a line of text
[lines, numlines] = mgetl(inData);

arr = [];

for curline=1:numlines
    line = lines{curline};
    if (~isempty(line)), line = strtrim(line); end

    % strip any comments
    if (strfind(line, '#') > 1), line = strtrim(line(1:ctest-1)); end

    if (strfind(line, '='))
        % this is an assigned value; parse it
        varcell = textscan(line, '%s=%s');
        varname = strtrim(varcell{1});
        value   = strtrim(varcell{2});
        
        if (strcmp(varname, 'UUID')), varargout{1} = value; end
        %if (strcmp(varname, 'ScanDate')), ScanDate = value; end
        if (strcmp(varname, 'LogVersion'))
            if (~strcmp(value, ExpectedVersion))
                error('File format [%s] not supported by this function (expected [%s]).', value, ExpectedVersion);
            end
        end
        if (strcmp(varname, 'LogDataType'))
            if (~strcmp(value, LogDataType))
                error('Expected [%s] data, found [%s]? Check filenames?', LogDataType, value);
            end
        end
        if (strcmp(varname, 'SampleTime'))
            if (strcmp(LogDataType, 'ACQUISITION_INFO'))
                error('Invalid [%s] parameter found.',varname);
            end
            SampleTime = uint16(str2double(value));
        end
        if (strcmp(varname, 'NumSlices'))
            if (~strcmp(LogDataType, 'ACQUISITION_INFO'))
                error('Invalid [%s] parameter found.',varname);
            end
            NumSlices = uint16(str2double(value));
            varargout{2} = NumSlices;
        end
        if (strcmp(varname, 'NumVolumes'))
            if (~strcmp(LogDataType, 'ACQUISITION_INFO'))
                error('Invalid [%s] parameter found.',varname);
            end
            NumVolumes = uint16(str2double(value));
            varargout{3} = NumVolumes;
        end
        if (strcmp(varname, 'FirstTime'))
            if (~strcmp(LogDataType, 'ACQUISITION_INFO'))
                error('Invalid [%s] parameter found.',varname);
            end
            FirstTime = uint32(str2double(value));
            varargout{4} = FirstTime;
        end
        if (strcmp(varname, 'LastTime'))
            if (~strcmp(LogDataType, 'ACQUISITION_INFO'))
                error('Invalid [%s] parameter found.',varname);
            end
            varargout{5} = uint32(str2double(value));
        end
        if (strcmp(varname, 'NumEchoes'))
            if (~strcmp(LogDataType, 'ACQUISITION_INFO'))
                error('Invalid [%s] parameter found.',varname);
            end
            NumEchoes = uint16(str2double(value));
            varargout{6} = NumEchoes;
        end
        
    elseif (~isempty(line))
        % this must be data; currently it is 3-5 columns so we can
        % parse it easily with textscan
        datacells = textscan(line, '%s %s %s %s %s');

        if (~isstrprop(datacells{1}{1}(1), 'digit'))
            % if the first column isn't numeric, it is probably the header
        else
            % store data in output array based on the file type
            if (strcmp(LogDataType, 'ACQUISITION_INFO'))
                if ( (1 ~= exist('NumVolumes', 'var')) || (NumVolumes < 1) || ...
                     (1 ~= exist('NumSlices' , 'var')) || (NumSlices  < 1) || ...
                     (1 ~= exist('NumEchoes' , 'var')) || (NumEchoes  < 1) )
                    error('Failed reading ACQINFO header!');
                end
                if (NumVolumes == 1)
                    % this is probably R016a or earlier diffusion data, where NumVolumes is 1 (incorrect)
                    NumVolumes = (numlines-11)/(NumSlices*NumEchoes);
                    warning('Found NumVolumes=1; correcting to %d for R016a and earlier diffusion data!', NumVolumes);
                end
                if (isempty(arr)), arr = zeros(2,NumVolumes,NumSlices,NumEchoes,'uint32'); end
                curvol    = uint16(str2double(datacells{1}{1})) + 1;
                curslc    = uint16(str2double(datacells{2}{1})) + 1;
                curstart  = uint32(str2double(datacells{3}{1}));
                curfinish = uint32(str2double(datacells{4}{1}));
                if (size(datacells{5},1))
                    cureco = uint16(str2double(datacells{5}{1})) + 1;
                    if (arr(:,curvol,curslc,cureco)), error('Received duplicate timing data for vol%d slc%d eco%d!', curvol, curslc, cureco); end
                else
                    cureco = uint16(0) + 1;
                    if (arr(:,curvol,curslc,cureco)), warning('Received duplicate timing data for vol%d slc%d (ignore for pre-R015a multi-echo data)!', curvol, curslc); end
                end
                arr(:,curvol,curslc,cureco) = [curstart curfinish]; %#ok<AGROW>
            else
                curstart   = uint32(str2double(datacells{1}{1})) - FirstTime + 1;
                curchannel = datacells{2}{1};
                curvalue   = uint16(str2double(datacells{3}{1}));
                %curtrigger = datacells{4}{1};

                if (strcmp(LogDataType, 'ECG'))
                    if (isempty(arr)), arr = zeros(ExpectedSamples,4,'uint16'); end
                    if (strcmp(curchannel, 'ECG1'))
                        chaidx = 1;
                    elseif (strcmp(curchannel, 'ECG2'))
                        chaidx = 2;
                    elseif (strcmp(curchannel, 'ECG3'))
                        chaidx = 3;
                    elseif (strcmp(curchannel, 'ECG4'))
                        chaidx = 4;
                    else
                        error('Invalid ECG channel ID [%s]', curchannel);
                    end
                elseif (strcmp(LogDataType, 'EXT'))
                    if (isempty(arr)), arr = zeros(ExpectedSamples,2,'uint16'); end
                    if (strcmp(curchannel, 'EXT'))
                        chaidx = 1;
                    elseif (strcmp(curchannel, 'EXT2'))
                        chaidx = 2;
                    else
                        error('Invalid EXT channel ID [%s]', curchannel);
                    end
                else
                    if (isempty(arr)), arr = zeros(ExpectedSamples,1,'uint16'); end
                    chaidx = 1;
                end
                
                arr(curstart:curstart+uint32(SampleTime-1),chaidx) = curvalue*ones(SampleTime,1,'uint16'); %#ok<AGROW>
            end
        end
    end
end

if (strcmp(LogDataType, 'ACQUISITION_INFO'))
    arr = arr - FirstTime;
end

%--------------------------------------------------------------------------

function [lines, numlines] = mgetl(arr)
% mgetl: parse an entire text file into cell array of strings where each
% cell is one line. recognizes dos and unix file formats.

arr = char(arr);
if (size(arr,1) > size(arr,2)), arr = arr'; end
arr_len = length(arr);
lf = strfind(arr, char(10));
numlines = length(lf);
if (lf(numlines) < arr_len)
    numlines = numlines + 1;
    lf(numlines) = arr_len;
end

lines = cell(numlines, 1);

stpos = 1;
for x=1:numlines
    if (x > 1), stpos = lf(x-1)+1; end
    endpos = lf(x) - 1;
    if (lf(x) > 1)
        if (arr(endpos) == char(13))
            endpos = endpos - 1; % strip cr and lf if both present
        end
    end
    if (endpos >= stpos), lines{x} = arr(stpos:endpos); end
end

%--------------------------------------------------------------------------

function [newminy, newmaxy] = plot_trace(trace, oldminy, oldmaxy, color, scale)
% plot trace and keep track of minimum and maximum values

miny = double(min(trace));
maxy = double(max(trace));
newminy = min(oldminy, miny);
newmaxy = max(oldmaxy, maxy);
if (scale && ((miny ~= oldminy) || (maxy ~= oldmaxy)))
    trace = double(trace) .* ((newmaxy-newminy)/(maxy-miny));
    trace = trace - min(trace) + newminy;
end
plot(trace,'Color',color);
